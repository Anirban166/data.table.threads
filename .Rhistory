c(Inf, -Inf, NaN),
c(rep(1, 1e6), rep(-1, 1e6)),
rnorm(1e6, mean = 0, sd = 1e5),
runif(1e6, min = -1e5, max = 1e5),
c(rnorm(1e6, mean = 0, sd = 1e5), rep(1, 1e6), .Machine$double.xmax),
c(rep(.Machine$double.eps, 1e6), rep(-.Machine$double.eps, 1e6)),
c(rep(.Machine$double.xmin, 1e6), rep(-.Machine$double.xmin, 1e6)),
c(rep(1e308, 1e3), rep(-1e308, 1e3)),
c(1 + 7i, 11 + 8i, 5 + 21i)
)
for(i in seq_along(testInputs))
{
cat("Test case", i, ":\n")
cat(meanComparison(testInputs[[i]], na.rm = TRUE), "\n")
}
library(data.table)
meanComparison <- function(x, na.rm)
{
baseR <- mean(x, na.rm = TRUE)
# fastmean <- .External("Cfastmean", x, ...)
options(datatable.optimize=1)
fastmean <- dt[, mean(values, na.rm = TRUE), verbose = TRUE]
cat("Results as computed by:\nBase R's mean:", baseR, "\ndata.table's fast mean:", fastmean, "\n")
fifelse(identical(baseR, fastmean), "Passed", "Failed")
}
testInputs <- list(
c(1e10, -1e10, 1e-10, -1e-10, 0),
c(Inf, -Inf, NaN),
c(rep(1, 1e6), rep(-1, 1e6)),
rnorm(1e6, mean = 0, sd = 1e5),
runif(1e6, min = -1e5, max = 1e5),
c(rnorm(1e6, mean = 0, sd = 1e5), rep(1, 1e6), .Machine$double.xmax),
c(rep(.Machine$double.eps, 1e6), rep(-.Machine$double.eps, 1e6)),
c(rep(.Machine$double.xmin, 1e6), rep(-.Machine$double.xmin, 1e6)),
c(rep(1e308, 1e3), rep(-1e308, 1e3)),
c(1 + 7i, 11 + 8i, 5 + 21i)
)
for(i in seq_along(testInputs))
{
cat("Test case", i, ":\n")
cat(meanComparison(testInputs[[i]], na.rm = TRUE), "\n")
}
library(data.table)
meanComparison <- function(x, na.rm)
{
baseR <- mean(x, na.rm = TRUE)
# fastmean <- .External("Cfastmean", x, ...)
options(datatable.optimize=1)
fastmean <- dt[, mean(values, na.rm = TRUE), verbose = TRUE]
cat("Results as computed by:\nBase R's mean:", baseR, "\ndata.table's fast mean:", fastmean, "\n")
fifelse(identical(baseR, fastmean), "Passed", "Failed")
}
testInputs <- list(
c(.Machine$double.xmax, -.Machine$double.xmax, 0),
c(1e10, -1e10, 1e-10, -1e-10, 0),
c(Inf, -Inf, NaN),
c(rep(1, 1e6), rep(-1, 1e6)),
rnorm(1e6, mean = 0, sd = 1e5),
runif(1e6, min = -1e5, max = 1e5),
c(rnorm(1e6, mean = 0, sd = 1e5), rep(1, 1e6), .Machine$double.xmax),
c(rep(.Machine$double.eps, 1e6), rep(-.Machine$double.eps, 1e6)),
c(rep(.Machine$double.xmin, 1e6), rep(-.Machine$double.xmin, 1e6)),
c(rep(1e308, 1e3), rep(-1e308, 1e3)),
c(1 + 7i, 11 + 8i, 5 + 21i)
)
for(i in seq_along(testInputs))
{
cat("Test case", i, ":\n")
cat(meanComparison(testInputs[[i]], na.rm = TRUE), "\n")
}
library(data.table)
meanComparison <- function(x, na.rm)
{
baseR <- mean(x, na.rm = TRUE)
# fastmean <- .External("Cfastmean", x, ...)
options(datatable.optimize=1)
fastmean <- dt[, mean(x, na.rm = TRUE), verbose = TRUE]
cat("Results as computed by:\nBase R's mean:", baseR, "\ndata.table's fast mean:", fastmean, "\n")
fifelse(identical(baseR, fastmean), "Passed", "Failed")
}
testInputs <- list(
c(.Machine$double.xmax, -.Machine$double.xmax, 0),
c(1e10, -1e10, 1e-10, -1e-10, 0),
c(Inf, -Inf, NaN),
c(rep(1, 1e6), rep(-1, 1e6)),
rnorm(1e6, mean = 0, sd = 1e5),
runif(1e6, min = -1e5, max = 1e5),
c(rnorm(1e6, mean = 0, sd = 1e5), rep(1, 1e6), .Machine$double.xmax),
c(rep(.Machine$double.eps, 1e6), rep(-.Machine$double.eps, 1e6)),
c(rep(.Machine$double.xmin, 1e6), rep(-.Machine$double.xmin, 1e6)),
c(rep(1e308, 1e3), rep(-1e308, 1e3)),
c(1 + 7i, 11 + 8i, 5 + 21i)
)
for(i in seq_along(testInputs))
{
cat("Test case", i, ":\n")
cat(meanComparison(testInputs[[i]], na.rm = TRUE), "\n")
}
library(data.table)
meanComparison <- function(x, na.rm)
{
baseR <- mean(x, na.rm = TRUE)
# fastmean <- .External("Cfastmean", x, ...)
options(datatable.optimize=1)
fastmean <- dt[, mean(x, na.rm = TRUE), verbose = TRUE]
cat("Results as computed by:\nBase R's mean:", baseR, "\ndata.table's fast mean:", fastmean, "\n")
fifelse(identical(baseR, fastmean), "Passed", "Failed")
}
testInputs <- list(
c(.Machine$double.xmax, -.Machine$double.xmax, 0),
c(1e10, -1e10, 1e-10, -1e-10, 0),
c(Inf, -Inf, NaN),
c(rep(1, 1e6), rep(-1, 1e6)),
rnorm(1e6, mean = 0, sd = 1e5),
runif(1e6, min = -1e5, max = 1e5),
c(rnorm(1e6, mean = 0, sd = 1e5), rep(1, 1e6), .Machine$double.xmax),
c(rep(.Machine$double.eps, 1e6), rep(-.Machine$double.eps, 1e6)),
c(rep(.Machine$double.xmin, 1e6), rep(-.Machine$double.xmin, 1e6)),
c(rep(1e308, 1e3), rep(-1e308, 1e3)),
c(1 + 7i, 11 + 8i, 5 + 21i)
)
for(i in seq_along(testInputs))
{
cat("Test case", i, ":\n")
cat(meanComparison(testInputs[[i]], na.rm = TRUE), "\n")
}
library(data.table)
meanComparison <- function(x, na.rm)
{
baseR <- mean(x, na.rm = TRUE)
# Create a data.table from the input vector x
dt <- data.table(values = x)
# Calculate mean using data.table
options(datatable.optimize = 1)
fastmean <- dt[, mean(values, na.rm = TRUE)]
cat("Results as computed by:\nBase R's mean:", baseR, "\ndata.table's fast mean:", fastmean, "\n")
fifelse(identical(baseR, fastmean), "Passed", "Failed")
}
testInputs <- list(
c(.Machine$double.xmax, -.Machine$double.xmax, 0),
c(1e10, -1e10, 1e-10, -1e-10, 0),
c(Inf, -Inf, NaN),
c(rep(1, 1e6), rep(-1, 1e6)),
rnorm(1e6, mean = 0, sd = 1e5),
runif(1e6, min = -1e5, max = 1e5),
c(rnorm(1e6, mean = 0, sd = 1e5), rep(1, 1e6), .Machine$double.xmax),
c(rep(.Machine$double.eps, 1e6), rep(-.Machine$double.eps, 1e6)),
c(rep(.Machine$double.xmin, 1e6), rep(-.Machine$double.xmin, 1e6)),
c(rep(1e308, 1e3), rep(-1e308, 1e3)),
c(1 + 7i, 11 + 8i, 5 + 21i)
)
for(i in seq_along(testInputs))
{
cat("Test case", i, ":\n")
cat(meanComparison(testInputs[[i]], na.rm = TRUE), "\n")
}
library(data.table)
meanComparison <- function(x, na.rm)
{
baseR <- mean(x, na.rm = TRUE)
# Create a data.table from the input vector x
dt <- data.table(values = x)
# Calculate mean using data.table
options(datatable.optimize = 1)
fastmean <- dt[, mean(values, na.rm = TRUE)]
cat("Results as computed by:\nBase R's mean:", baseR, "\ndata.table's fast mean:", fastmean, "\n")
fifelse(identical(baseR, fastmean), "Passed", "Failed")
}
testInputs <- list(
c(.Machine$double.xmax, -.Machine$double.xmax, 0),
c(1e10, -1e10, 1e-10, -1e-10, 0),
c(Inf, -Inf, NaN),
c(rep(1, 1e6), rep(-1, 1e6)),
rnorm(1e6, mean = 0, sd = 1e5),
runif(1e6, min = -1e5, max = 1e5),
c(rnorm(1e6, mean = 0, sd = 1e5), rep(1, 1e6), .Machine$double.xmax),
c(rep(.Machine$double.eps, 1e6), rep(-.Machine$double.eps, 1e6)),
c(rep(.Machine$double.xmin, 1e6), rep(-.Machine$double.xmin, 1e6)),
c(rep(1e308, 1e3), rep(-1e308, 1e3)),
c(1 + 7i, 11 + 8i, 5 + 21i)
)
for(i in seq_along(testInputs))
{
cat("Test case", i, ":\n", sep = "")
cat(meanComparison(testInputs[[i]], na.rm = TRUE), "\n")
}
meanComparison <- function(x, na.rm)
{
baseR <- mean(x, na.rm = TRUE)
dt <- data.table(x)
options(datatable.optimize = 1)
fastmean <- dt[, mean(x, na.rm = TRUE)]
cat("Results as computed by:\nBase R's mean:", baseR, "\ndata.table's fast mean:", fastmean, "\n")
fifelse(identical(baseR, fastmean), "Passed", "Failed")
}
testInputs <- list(
c(.Machine$double.xmax, -.Machine$double.xmax, 0),
c(1e10, -1e10, 1e-10, -1e-10, 0),
c(Inf, -Inf, NaN),
c(rep(1, 1e6), rep(-1, 1e6)),
rnorm(1e6, mean = 0, sd = 1e5),
runif(1e6, min = -1e5, max = 1e5),
c(rnorm(1e6, mean = 0, sd = 1e5), rep(1, 1e6), .Machine$double.xmax),
c(rep(.Machine$double.eps, 1e6), rep(-.Machine$double.eps, 1e6)),
c(rep(.Machine$double.xmin, 1e6), rep(-.Machine$double.xmin, 1e6)),
c(rep(1e308, 1e3), rep(-1e308, 1e3)),
c(1 + 7i, 11 + 8i, 5 + 21i)
)
for(i in seq_along(testInputs))
{
cat("Test case ", i, ":\n", sep = "")
cat(meanComparison(testInputs[[i]], na.rm = TRUE), "\n")
}
library(data.table)
# Create a data.table
dt <- data.table(
id = 1:10,
value = c(5, 7, 10, 3, 6, 8, 10, 4, 9, 2)
)
# Define max for the test
max_value <- 10
dt <- data.table(a = 1:5)
index <- c(-1, NA_integer_)
tryCatch({
result <- dt[index]
stop("Failed.")
}, error = function(e) {
message("Passed.")
})
library(data.table)
dt <- data.table(a = 1:5)
index <- seq_len(max(dt$a))
expectedResult <- dt[seq(1, 4)]
result <- tryCatch({
dt[index]
}, error = function(e) {
NULL
})
if(!identical(result, expectedResult))
stop("Test failed.")
test_that("subset function handles elem equal to max correctly", {
vec <- c(1, 2, 3, 4, 5)
max_value <- 5
result <- subset_function(vec, max_value)
# Original code should skip the element equal to max, so the result should exclude it
expected <- c(1, 2, 3, 4)
expect_equal(result, expected)
})
library(data.table)
options(datatable.optimize=1)
meanComparison <- function(x, ...)
{
baseR <- mean(x, ...)
fastmean <- .External("Cfastmean", x, ...)
cat("Results as computed by:\nBase R's mean:", baseR, "\ndata.table's fast mean:", fastmean, "\n")
fifelse(identical(baseR, fastmean), "Passed", "Failed")
}
testInputs <- list(
c(rep(1e308, 1e3), rep(-1e308, 1e3)),
c(rnorm(1e6, mean = 0, sd = 1e5), rep(1, 1e6), .Machine$double.xmax)
)
for(i in seq_along(testInputs))
{
cat("Test case ", i, ":\n", sep = "")
cat(meanComparison(testInputs[[i]], na.rm = TRUE), "\n")
}
library(data.table)
options(datatable.optimize=1)
meanComparison <- function(x, ...)
{
baseR <- mean(x, ...)
fastmean <- .External("Cfastmean", x, ...)
cat("Results as computed by:\nBase R's mean:", baseR, "\ndata.table's fast mean:", fastmean, "\n")
fifelse(identical(baseR, fastmean), "Passed", "Failed")
}
testInputs <- list(
c(rep(1e308, 1e3), rep(-1e308, 1e3)),
c(rnorm(1e6, mean = 0, sd = 1e5), rep(1, 1e6), .Machine$double.xmax)
)
for(i in seq_along(testInputs))
{
cat("Test case ", i, ":\n", sep = "")
cat(meanComparison(testInputs[[i]], na.rm = TRUE), "\n")
}
library(data.table)
dt <- data.table(
id_1 = 1:3,
id_2 = letters[1:3],
letter_1 = LETTERS[1:3],
letter_2 = LETTERS[4:6]
)
melt(dt, measure.vars = patterns("_\\d$", cols = paste0("letter_", 1:2)))
library(data.table)
dt <- data.table(
id_1 = 1:3,
id_2 = letters[1:3],
letter_1 = LETTERS[1:3],
letter_2 = LETTERS[4:6]
)
melt(dt, measure.vars = patterns("^letter_", cols = names(dt)))
library(data.table)
dt <- data.table(
id_1 = 1:3,
id_2 = letters[1:3],
letter_1 = LETTERS[1:3],
letter_2 = LETTERS[4:6]
)
melt(dt, measure.vars = c("letter_1", "letter_2"))
melt(dt, measure.vars = patterns("^letter_", cols = names(dt)))
melt(dt, measure.vars = patterns("^letter_")
)
melt(dt, measure.vars = patterns("^letter_"))
A case where cols becomes essential, and patterns alone can't reproduce the behavior, would be when you need to target a specific subset of columns for pattern matching within a larger data.table. Here’s an example where cols is critical:
dt <- data.table(
id = 1:3,
letter_1 = LETTERS[1:3],
letter_2 = LETTERS[4:6],
number_1 = 1:3,
number_2 = 4:6
)
# Now, you want to melt only `letter_1` and `letter_2` but ignore `number_` columns.
melt(dt, measure.vars = patterns("^letter_", cols = c("letter_1", "letter_2")))
dt <- data.table(
id = 1:3,
letter_1 = LETTERS[1:3],
letter_2 = LETTERS[4:6],
number_1 = 1:3,
number_2 = 4:6
)
library(data.table)
dt <- data.table(
id = 1:3,
letter_1 = LETTERS[1:3],
letter_2 = LETTERS[4:6],
number_1 = 1:3,
number_2 = 4:6
)
# Now, you want to melt only `letter_1` and `letter_2` but ignore `number_` columns.
melt(dt, measure.vars = patterns("^letter_", cols = c("letter_1", "letter_2")))
dt <- data.table(
id = 1:3,
letter_1 = LETTERS[1:3],
letter_2 = LETTERS[4:6],
number_1 = 1:3,
number_2 = 4:6
)
# Now, you want to melt only `letter_1` and `letter_2` but ignore `number_` columns.
melt(dt, measure.vars = patterns("^letter_", cols = c("letter_1", "letter_2")))
dt <- data.table(
id = 1:3,
letter_1 = LETTERS[1:3],
letter_2 = LETTERS[4:6],
number_1 = 1:3,
number_2 = 4:6
)
# Now, you want to melt only `letter_1` and `letter_2` but ignore `number_` columns.
melt(dt, measure.vars = patterns("^letter_", cols = c("letter_1", "letter_2")))
dt <- data.table(
id = 1:3,
letter_1 = LETTERS[1:3],
letter_2 = LETTERS[4:6],
number_1 = 1:3,
number_2 = 4:6
)
# Now, you want to melt only `letter_1` and `letter_2` but ignore `number_` columns.
melt(dt, measure.vars = patterns("^letter_")
)
dt <- data.table(
id = 1:3,
letter_1 = LETTERS[1:3],
letter_2 = LETTERS[4:6],
number_1 = 1:3,
number_2 = 4:6
)
# Now, you want to melt only `letter_1` and `letter_2` but ignore `number_` columns.
melt(dt, measure.vars = patterns("^letter_"))
setwd("/Users/anirban166/data.table.threads")
library(devtools)
load_all()
(x <- findOptimalThreadCount(1e7, 10, verbose = FALSE))
system("R CMD build .")
getAnywhere("melt.data.table")
system("R CMD build .")
pkg.edit.fun = function(old.Package, new.Package, sha, new.pkg.path) {
pkg_find_replace <- function(glob, FIND, REPLACE) {
atime::glob_find_replace(file.path(new.pkg.path, glob), FIND, REPLACE)
}
Package_regex <- gsub(".", "_?", old.Package, fixed = TRUE)
Package_ <- gsub(".", "_", old.Package, fixed = TRUE)
new.Package_ <- paste0(Package_, "_", sha)
pkg_find_replace(
"DESCRIPTION",
paste0("Package:\\s+", old.Package),
paste("Package:", new.Package))
pkg_find_replace(
file.path("src", "Makevars.*in"),
Package_regex,
new.Package_)
pkg_find_replace(
file.path("R", "onLoad.R"),
Package_regex,
new.Package_)
pkg_find_replace(
file.path("R", "onLoad.R"),
sprintf('packageVersion\\("%s"\\)', old.Package),
sprintf('packageVersion\\("%s"\\)', new.Package))
pkg_find_replace(
file.path("src", "init.c"),
paste0("R_init_", Package_regex),
paste0("R_init_", gsub("[.]", "_", new.Package_)))
pkg_find_replace(
"NAMESPACE",
sprintf('useDynLib\\("?%s"?', Package_regex),
paste0('useDynLib(', new.Package_))
}
expr.list <- atime::atime_versions_exprs(
pkg.path="~/R/data.table",
pkg.edit.fun=pkg.edit.fun,
expr = data.table:::transform.data.table(dt, y = round(x)),
Fast = "2d1a0575f87cc50e90f64825c30d7a6cb6b05dd7", # Merge commit
Slow = "0895fa247afcf6b38044bd5f56c0d209691ddb31") # Parent of the first commit (https://github.com/Rdatatable/data.table/commit/93ce3ce1373bf733ebd2036e2883d2ffe377ab58) in the PR (https://github.com/Rdatatable/data.table/pull/5493/commits) that fixes the issue
install.packages("data.table")
install.packages("data.table")
pkg.edit.fun = function(old.Package, new.Package, sha, new.pkg.path) {
pkg_find_replace <- function(glob, FIND, REPLACE) {
atime::glob_find_replace(file.path(new.pkg.path, glob), FIND, REPLACE)
}
Package_regex <- gsub(".", "_?", old.Package, fixed = TRUE)
Package_ <- gsub(".", "_", old.Package, fixed = TRUE)
new.Package_ <- paste0(Package_, "_", sha)
pkg_find_replace(
"DESCRIPTION",
paste0("Package:\\s+", old.Package),
paste("Package:", new.Package))
pkg_find_replace(
file.path("src", "Makevars.*in"),
Package_regex,
new.Package_)
pkg_find_replace(
file.path("R", "onLoad.R"),
Package_regex,
new.Package_)
pkg_find_replace(
file.path("R", "onLoad.R"),
sprintf('packageVersion\\("%s"\\)', old.Package),
sprintf('packageVersion\\("%s"\\)', new.Package))
pkg_find_replace(
file.path("src", "init.c"),
paste0("R_init_", Package_regex),
paste0("R_init_", gsub("[.]", "_", new.Package_)))
pkg_find_replace(
"NAMESPACE",
sprintf('useDynLib\\("?%s"?', Package_regex),
paste0('useDynLib(', new.Package_))
}
expr.list <- atime::atime_versions_exprs(
pkg.path="~/R/data.table",
pkg.edit.fun=pkg.edit.fun,
expr = data.table:::transform.data.table(dt, y = round(x)),
Fast = "2d1a0575f87cc50e90f64825c30d7a6cb6b05dd7", # Merge commit
Slow = "0895fa247afcf6b38044bd5f56c0d209691ddb31") # Parent of the first commit (https://github.com/Rdatatable/data.table/commit/93ce3ce1373bf733ebd2036e2883d2ffe377ab58) in the PR (https://github.com/Rdatatable/data.table/pull/5493/commits) that fixes the issue
pkg.edit.fun = function(old.Package, new.Package, sha, new.pkg.path) {
pkg_find_replace <- function(glob, FIND, REPLACE) {
atime::glob_find_replace(file.path(new.pkg.path, glob), FIND, REPLACE)
}
Package_regex <- gsub(".", "_?", old.Package, fixed = TRUE)
Package_ <- gsub(".", "_", old.Package, fixed = TRUE)
new.Package_ <- paste0(Package_, "_", sha)
pkg_find_replace(
"DESCRIPTION",
paste0("Package:\\s+", old.Package),
paste("Package:", new.Package))
pkg_find_replace(
file.path("src", "Makevars.*in"),
Package_regex,
new.Package_)
pkg_find_replace(
file.path("R", "onLoad.R"),
Package_regex,
new.Package_)
pkg_find_replace(
file.path("R", "onLoad.R"),
sprintf('packageVersion\\("%s"\\)', old.Package),
sprintf('packageVersion\\("%s"\\)', new.Package))
pkg_find_replace(
file.path("src", "init.c"),
paste0("R_init_", Package_regex),
paste0("R_init_", gsub("[.]", "_", new.Package_)))
pkg_find_replace(
"NAMESPACE",
sprintf('useDynLib\\("?%s"?', Package_regex),
paste0('useDynLib(', new.Package_))
}
expr.list <- atime::atime_versions_exprs(
pkg.path="~/data.table",
pkg.edit.fun=pkg.edit.fun,
expr = data.table:::transform.data.table(dt, y = round(x)),
Fast = "2d1a0575f87cc50e90f64825c30d7a6cb6b05dd7", # Merge commit
Slow = "0895fa247afcf6b38044bd5f56c0d209691ddb31") # Parent of the first commit (https://github.com/Rdatatable/data.table/commit/93ce3ce1373bf733ebd2036e2883d2ffe377ab58) in the PR (https://github.com/Rdatatable/data.table/pull/5493/commits) that fixes the issue
library(data.table)
vres <- atime::atime(
N=2^seq(1,20),
setup = {
set.seed(1)
df <- data.frame(x = runif(N))
dt <- as.data.table(df)
},
expr.list=expr.list,
df=transform(df, y = round(x)))
vref <- atime::references_best(vres)
vpre <- predict(vref)
plot(vpre)
